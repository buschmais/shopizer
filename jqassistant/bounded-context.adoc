[[bounded-context:Default]]
[role=group,includesConcepts="bounded-context:*",includesConstraints="bounded-context:*"]
=== Bounded Context

The application consists of `Bounded Contexts`, each of them consisting of one or more Maven artifacts.

[[bounded-context:BoundedContext]]
[source,cypher,role=concept]
.Defined Bounded Contexts and their mapping to Maven artifacts.
----
UNWIND
  [
    {id:"Core", artifacts:["sm-core","sm-core-model-api","sm-core-model","sm-core-modules","sm-shop"]},
    {id:"Catalog", artifacts:["sm-catalog"]}
  ] as definition
UNWIND
  definition.artifacts as artifactId
MATCH
  (bc:Main:Artifact{name:artifactId})
SET
  bc:BoundedContext
SET
  bc.boundedContext = definition.id
RETURN
  bc.boundedContext as BoundedContext, collect(bc.name) as Artifacts
----

There may be well-defined dependencies between different bounded contexts.
The goal is to have a cycle-free dependency graph that allows for:

- determining the impact of changes between bounded contexts
- defined lifecycle dependencies of bounded contexts at runtime (e.g. to control startup-/shutdown order)

[[bounded-context:DefinedDependency]]
[source,cypher,role=concept,requiresConcepts="bounded-context:BoundedContext",reportType="plantuml-component-diagram"]
.Definition of allowed dependencies between different bounded contexts. They are mapped to Maven artifacts that represent public interfaces of each bounded context.
----
MATCH
  (core:BoundedContext:Artifact{name:"sm-core"}),
  (coreModelApi:BoundedContext:Artifact{name:"sm-core-model-api"}),
  (shop:BoundedContext:Artifact{name:"sm-shop"}),
  (catalog:BoundedContext:Artifact{name:"sm-catalog"})
MERGE
  (core)-[d1:DEFINES_BC_DEPENDENCY]->(catalog)
MERGE
  (shop)-[d2:DEFINES_BC_DEPENDENCY]->(catalog)
MERGE
  (catalog)-[d3:DEFINES_BC_DEPENDENCY]->(coreModelApi)
RETURN
  *
----

Dependencies between bounded contexts are introduced by creating references between Java types, e.g. by

- injecting services
- inheritance
- used annotations
- type parameters
- ...

A higher number of references causes higher `Coupling` between bounded contexts.
The aim should be to keep the numbers as low as possible.

[[bounded-context:Dependency]]
[source,cypher,role=concept,requiresConcepts="bounded-context:BoundedContext"]
.A dependency between two bounded contexts is caused by dependencies between Java types.
----
MATCH
  (bc1:BoundedContext:Artifact)-[:CONTAINS]->(t1:Type),
  (bc2:BoundedContext:Artifact)-[:CONTAINS]->(t2:Type),
  (t1)-[dependsOn:DEPENDS_ON]->(t2)
WHERE
  bc1.boundedContext <> bc2.boundedContext
WITH
  bc1, bc2, count(dependsOn) as coupling, sum(dependsOn.weight) as totalCoupling
MERGE
  (bc1)-[dependsOnBC:DEPENDS_ON_BC]->(bc2)
RETURN
  bc1.boundedContext as BoundedContext, bc2.boundedContext as Dependency, coupling as Coupling, totalCoupling as TotalCoupling
----

During development dependencies between bounded contexts may be introduced that do not match the defined dependencies above.
This situation is verified during build time.
A detected violation must be resolved by either

- removing the newly introduced dependency
- or explicitly defining the dependency if applicable

[[bounded-context:UndefinedDependency]]
[source,cypher,role=constraint,requiresConcepts="bounded-context:Dependency,bounded-context:DefinedDependency"]
.A bounded context must only have dependencies to other bounded contexts that are defined.
----
MATCH
  (bc1:BoundedContext:Artifact)-[:DEPENDS_ON_BC]->(bc2:BoundedContext:Artifact)
WHERE
  not (bc1)-[:DEFINES_BC_DEPENDENCY]->(bc2)
WITH
  bc1, bc2
MATCH
  (bc1)-[:CONTAINS]->(t1:Type),
  (bc2)-[:CONTAINS]->(t2:Type),
  (t1)-[dependsOn:DEPENDS_ON]->(t2)
RETURN
  bc1.boundedContext as BoundedContext, t1 as Type, bc2.boundedContext as Dependency, t2 as TypeDependency
----

The coupling between bounded contexts must be kept at a lowest possible minimum that guarantees the expected functionality and quality of services (e.g. performance).

[[bounded-context:ExportedType]]
[source,cypher,role=concept,requiresConcepts="bounded-context:BoundedContext"]
.A type is exported from a bounded context if it is imported (i.e. used) by another bounded context.
----
MATCH
  (bc1:BoundedContext:Artifact)-[:CONTAINS]->(t1:Type),
  (bc2:BoundedContext:Artifact)-[:CONTAINS]->(t2:Type),
  (t1)-[:DEPENDS_ON]->(t2)
WHERE
  bc1.boundedContext <> bc2.boundedContext
RETURN
  bc2.boundedContext as Exporter, t2.fqn as ExportedType, bc1.boundedContext as Importer, count(t1) as ImportingTypes
ORDER BY
  Exporter, ExportedType, Importer, ImportingTypes
----

For maintainability reasons it is important to have clear set of defined types that may be exchanged by different bounded contexts.
This ensures encapsulation of implementation details and enables independent evolution.

[[bounded-context:ExportedTypeMustBeInterfaceOrDTO]]
[source,cypher,role=constraint,requiresConcepts="bounded-context:BoundedContext,dto:DTO"]
.A bounded context must only depend on types from another bounded context that are either Java interfaces or DTOs.
----
MATCH
  (bc1:BoundedContext:Artifact)-[:CONTAINS]->(t1:Type),
  (bc2:BoundedContext:Artifact)-[:CONTAINS]->(t2:Type),
  (t1)-[:DEPENDS_ON]->(t2)
WHERE
  bc1.boundedContext <> bc2.boundedContext
  and not (
    t2:Interface or t2:DTO
  )
RETURN
  bc2.name as Exporter, t2.fqn as ExportedType, bc1.name as Importer, t1.fqn as ImportingType
----

